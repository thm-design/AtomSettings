"use strict";
var startsWith = require("core-js/library/fn/string/starts-with");
var typescript = require("typescript");
function parseImports(code) {
    var host = {
        fileExists: function () { return true; },
        readFile: function () { return ""; },
        getSourceFile: function () {
            return typescript.createSourceFile("", code, typescript.ScriptTarget.Latest, true);
        },
        getDefaultLibFileName: function () { return "lib.d.ts"; },
        writeFile: function () { return null; },
        getCurrentDirectory: function () { return ""; },
        getDirectories: function () { return []; },
        getCanonicalFileName: function (fileName) { return fileName; },
        useCaseSensitiveFileNames: function () { return true; },
        getNewLine: function () { return typescript.sys.newLine; },
    };
    var program = typescript.createProgram(["foo.ts"], {
        noResolve: true,
        target: typescript.ScriptTarget.Latest,
        experimentalDecorators: true,
        experimentalAsyncFunctions: true,
    }, host);
    var sourceFile = program.getSourceFile("foo.ts");
    var imports = [];
    typescript.forEachChild(sourceFile, function (node) {
        switch (node.kind) {
            case typescript.SyntaxKind.ImportDeclaration: {
                imports.push(parseImportDeclaration(code, sourceFile, node));
                break;
            }
            case typescript.SyntaxKind.ImportEqualsDeclaration: {
                break;
            }
            default: {
                break;
            }
        }
    });
    return imports;
}
exports.parseImports = parseImports;
function parseImportDeclaration(code, sourceFile, importDeclaration) {
    var start = importDeclaration.pos + importDeclaration.getLeadingTriviaWidth();
    var end = importDeclaration.end;
    var leadingComments = getComments(sourceFile, importDeclaration, false);
    var trailingComments = getComments(sourceFile, importDeclaration, true);
    if (leadingComments) {
        var comments = leadingComments;
        var current = leadingComments.length - 1;
        var previous = void 0;
        while (comments[current] && comments[current].end + 1 === start) {
            if (startsWith(code.substring(comments[current].pos, comments[current].end), "#!")) {
                break;
            }
            previous = current;
            start = comments[previous].pos;
            current--;
        }
    }
    if (trailingComments) {
        var comments = trailingComments;
        var current = 0;
        var previous = void 0;
        while (comments[current] && comments[current].pos - 1 === end) {
            // TODO: Why is this not needed?
            // if (comments[current].loc.start.line !== node.loc.start.line) {
            //   break;
            // }
            previous = current;
            end = comments[previous].end;
            current++;
        }
    }
    var type = "import";
    var moduleName = importDeclaration.moduleSpecifier.getText().replace(/"/g, "");
    var imported = {
        start: start,
        end: end,
        type: type,
        moduleName: moduleName,
        namedMembers: [],
    };
    var importClause = importDeclaration.importClause;
    if (importClause) {
        if (importClause.name) {
            imported.defaultMember = importClause.name.text;
        }
        var namedBindings = importClause.namedBindings;
        if (namedBindings) {
            if (namedBindings.kind === typescript.SyntaxKind.NamespaceImport) {
                var namespaceImport = namedBindings;
                imported.namespaceMember = namespaceImport.name.text;
            }
            if (namedBindings.kind === typescript.SyntaxKind.NamedImports) {
                var namedImports = namedBindings;
                for (var _i = 0, _a = namedImports.elements; _i < _a.length; _i++) {
                    var element = _a[_i];
                    var alias = element.name.text;
                    var name_1 = alias;
                    if (element.propertyName) {
                        name_1 = element.propertyName.text;
                    }
                    imported.namedMembers.push({ name: name_1, alias: alias });
                }
            }
        }
    }
    return imported;
}
// Taken from https://github.com/fkling/astexplorer/blob/master/src/parsers/js/typescript.js#L68
function getComments(sourceFile, node, isTrailing) {
    if (node.parent) {
        var nodePos = isTrailing ? node.end : node.pos;
        var parentPos = isTrailing ? node.parent.end : node.parent.pos;
        if (node.parent.kind === typescript.SyntaxKind.SourceFile || nodePos !== parentPos) {
            var comments = void 0;
            if (isTrailing) {
                comments = typescript.getTrailingCommentRanges(sourceFile.text, nodePos);
            }
            else {
                comments = typescript.getLeadingCommentRanges(sourceFile.text, nodePos);
            }
            if (Array.isArray(comments)) {
                return comments;
            }
        }
    }
}
;
function formatImport(code, imported) {
    var originalImportCode = code.substring(imported.start, imported.end);
    var namedMembers = imported.namedMembers;
    if (namedMembers.length === 0) {
        return originalImportCode;
    }
    return originalImportCode.replace(/\{[\s\S]*\}/g, function (namedMembersString) {
        var useMultipleLines = namedMembersString.indexOf("\n") !== -1;
        var prefix;
        if (useMultipleLines) {
            prefix = namedMembersString.split("\n")[1].match(/^\s*/)[0];
        }
        var useSpaces = namedMembersString.charAt(1) === " ";
        return formatNamedMembers(namedMembers, useMultipleLines, useSpaces, prefix);
    });
}
exports.formatImport = formatImport;
function formatNamedMembers(namedMembers, useMultipleLines, useSpaces, prefix) {
    if (useMultipleLines) {
        return "{\n" + namedMembers.map(function (_a) {
            var name = _a.name, alias = _a.alias;
            if (name === alias) {
                return "" + prefix + name + ",\n";
            }
            return "" + prefix + name + " as " + alias + ",\n";
        }).join("") + "}";
    }
    else {
        var space = useSpaces ? " " : "";
        return "{" + space + namedMembers.map(function (_a) {
            var name = _a.name, alias = _a.alias;
            if (name === alias) {
                return "" + name;
            }
            return name + " as " + alias;
        }).join(", ") + space + "}";
    }
}

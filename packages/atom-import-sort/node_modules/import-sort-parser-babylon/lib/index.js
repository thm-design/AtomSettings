"use strict";
var babel_types_1 = require("babel-types");
var babylon_1 = require("babylon");
var babel_traverse_1 = require("babel-traverse");
// TODO: Mocha currently doesn't pick up the declaration in index.d.ts
var findLineColumn = require("find-line-column");
function parseImports(code) {
    var parsed = babylon_1.parse(code, {
        sourceType: "module",
        plugins: [
            "jsx",
            "flow",
            "doExpressions",
            "objectRestSpread",
            "decorators",
            "classProperties",
            "exportExtensions",
            "asyncGenerators",
            "functionBind",
            "functionSent",
        ],
    });
    var imports = [];
    babel_traverse_1.default(parsed, {
        ImportDeclaration: function (path) {
            var node = path.node;
            var start = node.start;
            var end = node.end;
            if (node.leadingComments) {
                var comments = node.leadingComments;
                var current = node.leadingComments.length - 1;
                var previous = void 0;
                while (comments[current] && comments[current].end + 1 === start) {
                    if (code.substring(comments[current].start, comments[current].end).indexOf("#!") === 0) {
                        break;
                    }
                    // TODO: Improve this so that comments with leading whitespace are allowed
                    if (findLineColumn(code, comments[current].start).col !== 0) {
                        break;
                    }
                    previous = current;
                    start = comments[previous].start;
                    current--;
                }
            }
            if (node.trailingComments) {
                var comments = node.trailingComments;
                var current = 0;
                var previous = void 0;
                while (comments[current] && comments[current].start - 1 === end) {
                    if (comments[current].loc.start.line !== node.loc.start.line) {
                        break;
                    }
                    previous = current;
                    end = comments[previous].end;
                    current++;
                }
            }
            var imported = {
                start: start,
                end: end,
                moduleName: node.source.value,
                type: "import",
                namedMembers: [],
            };
            if (node.specifiers) {
                node.specifiers.forEach(function (specifier) {
                    if (babel_types_1.isImportSpecifier(specifier)) {
                        imported.namedMembers.push({
                            name: specifier.imported.name,
                            alias: specifier.local.name,
                        });
                    }
                    else if (babel_types_1.isImportDefaultSpecifier(specifier)) {
                        imported.defaultMember = specifier.local.name;
                    }
                    else if (babel_types_1.isImportNamespaceSpecifier) {
                        imported.namespaceMember = specifier.local.name;
                    }
                });
            }
            imports.push(imported);
        },
    });
    return imports;
}
exports.parseImports = parseImports;
function formatImport(code, imported) {
    var originalImportCode = code.substring(imported.start, imported.end);
    var namedMembers = imported.namedMembers;
    if (namedMembers.length === 0) {
        return originalImportCode;
    }
    return originalImportCode.replace(/\{[\s\S]*\}/g, function (namedMembersString) {
        var useMultipleLines = namedMembersString.indexOf("\n") !== -1;
        var prefix;
        if (useMultipleLines) {
            prefix = namedMembersString.split("\n")[1].match(/^\s*/)[0];
        }
        var useSpaces = namedMembersString.charAt(1) === " ";
        return formatNamedMembers(namedMembers, useMultipleLines, useSpaces, prefix);
    });
}
exports.formatImport = formatImport;
function formatNamedMembers(namedMembers, useMultipleLines, useSpaces, prefix) {
    if (useMultipleLines) {
        return "{\n" + namedMembers.map(function (_a) {
            var name = _a.name, alias = _a.alias;
            if (name === alias) {
                return "" + prefix + name + ",\n";
            }
            return "" + prefix + name + " as " + alias + ",\n";
        }).join("") + "}";
    }
    else {
        var space = useSpaces ? " " : "";
        return "{" + space + namedMembers.map(function (_a) {
            var name = _a.name, alias = _a.alias;
            if (name === alias) {
                return "" + name;
            }
            return name + " as " + alias;
        }).join(", ") + space + "}";
    }
}

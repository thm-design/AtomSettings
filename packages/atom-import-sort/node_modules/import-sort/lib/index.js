"use strict";
var assign = require("core-js/library/fn/object/assign");
var findIndex = require("core-js/library/fn/array/find-index");
var StyleAPI_1 = require("./style/StyleAPI");
function importSort(code, rawParser, rawStyle) {
    var parser;
    var style;
    if (typeof rawParser === "string") {
        parser = require(rawParser);
    }
    else {
        parser = rawParser;
    }
    if (typeof rawStyle === "string") {
        style = require(rawStyle).default;
    }
    else {
        style = rawStyle;
    }
    return sortImports(code, parser, style);
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = importSort;
function sortImports(code, parser, style) {
    var items = addFallback(style)(StyleAPI_1.default);
    var buckets = items.map(function () { return []; });
    var imports = parser.parseImports(code);
    if (imports.length === 0) {
        return { code: code, changes: [] };
    }
    var changes = [];
    var _loop_1 = function (imported) {
        var sortedImport = imported;
        var index = findIndex(items, function (item) {
            sortedImport = sortNamedMembers(imported, item.sortNamedMembers);
            return !!item.match && item.match(sortedImport);
        });
        if (index !== -1) {
            buckets[index].push(sortedImport);
        }
    };
    // Fill buckets
    for (var _i = 0, imports_1 = imports; _i < imports_1.length; _i++) {
        var imported = imports_1[_i];
        _loop_1(imported);
    }
    // Sort buckets
    buckets.forEach(function (bucket, index) {
        var sort = items[index].sort;
        if (!sort) {
            return;
        }
        if (!Array.isArray(sort)) {
            bucket.sort(sort);
            return;
        }
        var sorters = sort;
        if (sorters.length === 0) {
            return;
        }
        var multiSort = function (first, second) {
            var sorterIndex = 0;
            var comparison = 0;
            while (comparison === 0 && sorters[sorterIndex]) {
                comparison = sorters[sorterIndex](first, second);
                sorterIndex++;
            }
            return comparison;
        };
        bucket.sort(multiSort);
    });
    var importsCode = "";
    // Track if we need to insert a separator
    var separator = false;
    buckets.forEach(function (bucket, index) {
        if (bucket.length > 0 && separator) {
            importsCode += "\n";
            separator = false;
        }
        bucket.forEach(function (imported) {
            // const sortedImport = sortNamedMembers(imported, items[index].sortNamedMembers);
            var importString = parser.formatImport(code, imported);
            importsCode += importString + "\n";
        });
        // Add separator but only when at least one import was already added
        if (items[index].separator && importsCode !== "") {
            separator = true;
        }
    });
    var sortedCode = code;
    // Remove imports
    imports.slice().reverse().forEach(function (imported) {
        var importEnd = imported.end;
        if (sortedCode.charAt(imported.end).match(/\s/)) {
            importEnd++;
        }
        changes.push({
            start: imported.start,
            end: importEnd,
            code: "",
            note: "import-remove",
        });
        sortedCode = sortedCode.slice(0, imported.start) + sortedCode.slice(importEnd, code.length);
    });
    var start = imports[0].start;
    // Split code at first original import
    var before = code.substring(0, start);
    var after = sortedCode.substring(start, sortedCode.length);
    var oldBeforeLength = before.length;
    var oldAfterLength = after.length;
    var beforeChange;
    var afterChange;
    // Collapse all whitespace into a single blank line
    before = before.replace(/\s+$/, function (match) {
        beforeChange = {
            start: start - match.length,
            end: start,
            code: "\n\n",
            note: "before-collapse",
        };
        return "\n\n";
    });
    // Collapse all whitespace into a single new line
    after = after.replace(/^\s+/, function (match) {
        afterChange = {
            start: start,
            end: start + match.length,
            code: "\n",
            note: "after-collapse",
        };
        return "\n";
    });
    // Remove all whitespace at the beginning of the code
    if (before.match(/^\s+$/)) {
        beforeChange = {
            start: start - oldBeforeLength,
            end: start,
            code: "",
            note: "before-trim",
        };
        before = "";
    }
    // Remove all whitespace at the end of the code
    if (after.match(/^\s+$/)) {
        afterChange = {
            start: start,
            end: start + oldAfterLength,
            code: "",
            note: "after-trim",
        };
        after = "";
    }
    if (afterChange) {
        changes.push(afterChange);
    }
    if (beforeChange) {
        changes.push(beforeChange);
    }
    var change = {
        start: before.length,
        end: before.length,
        code: importsCode,
        note: "imports",
    };
    changes.push(change);
    if (code === before + importsCode + after) {
        return { code: code, changes: [] };
    }
    return {
        code: before + importsCode + after,
        changes: changes,
    };
}
exports.sortImports = sortImports;
function sortNamedMembers(imported, rawSort) {
    var sort = rawSort;
    if (!sort) {
        return imported;
    }
    if (!Array.isArray(sort)) {
        var sortedImport_1 = assign({}, imported);
        sortedImport_1.namedMembers.sort(sort);
        return sortedImport_1;
    }
    var sorters = sort;
    if (sorters.length === 0) {
        return imported;
    }
    var multiSort = function (first, second) {
        var sorterIndex = 0;
        var comparison = 0;
        while (comparison === 0 && sorters[sorterIndex]) {
            comparison = sorters[sorterIndex](first, second);
            sorterIndex++;
        }
        return comparison;
    };
    var sortedImport = assign({}, imported);
    sortedImport.namedMembers.sort(multiSort);
    return sortedImport;
}
function applyChanges(code, changes) {
    var changedCode = code;
    for (var _i = 0, changes_1 = changes; _i < changes_1.length; _i++) {
        var change = changes_1[_i];
        changedCode = changedCode.slice(0, change.start) + change.code + changedCode.slice(change.end, changedCode.length);
    }
    return changedCode;
}
exports.applyChanges = applyChanges;
function addFallback(style) {
    return function (styleApi) {
        var items = [
            { separator: true },
            { match: styleApi.always },
        ];
        return style(styleApi).concat(items);
    };
}
